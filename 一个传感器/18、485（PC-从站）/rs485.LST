C51 COMPILER V9.01   RS485                                                                 08/10/2016 16:12:08 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE RS485
OBJECT MODULE PLACED IN rs485.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE rs485.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1           /*******************************************************************************************************
   2          *  :                  RS485ͨ(뷢)                                                 *
   3          *                                                                                                       *
   4          *  1.ͨ˽⴮ڵĻԭʹ ,ⲢնԴڽгʼ                                     *
   5          *                                                                                                       *
   6          *  2.ʹôڵ֣Baud 9600λ8ֹͣλ1ЧλޣΪλ()ݺ()ݣ      *
   7          *    ַַ(HEX),Ͱťۿܴʾ.ҲԶѭ͡        *
   8          *                                                                                                       *
   9          *  3.RS485ҪRS232ת485תͷA485תͷA  BӦ485תͷB.ӷҿԲοԭͼ     *
  10          ********************************************************************************************************/
  11          
  12          #include <reg52.h>
  13          #include <intrins.h>
  14           
  15          sbit RS485_DIR = P1^7;  //RS485ѡ
  16          
  17          bit flagOnceTxd = 0;  //ηɱ־һֽ
  18           
  19          bit cmdArrived = 0;   //־յλ·
  20          
  21          unsigned char cntRxd = 0;
  22          
  23          unsigned char pdata bufRxd[40]; //ڽջ
  24          
  25            
  26          void ConfigUART(unsigned int baud)  //úbaudΪ
  27          {
  28   1          RS485_DIR = 0; //RS485Ϊշ
  29   1          SCON = 0x50;   //ôΪģʽ1
  30   1          TMOD &= 0x0F;  //T1Ŀλ
  31   1          TMOD |= 0x20;  //T1Ϊģʽ2
  32   1          TH1 = 256 - (11059200/12/32) / baud;  //T1ֵ
  33   1          TL1 = TH1;     //ֵֵ
  34   1          ET1 = 0;       //ֹT1ж
  35   1          ES  = 1;       //ʹܴж
  36   1          TR1 = 1;       //T1
  37   1      }
  38          
  39          unsigned char UartRead(unsigned char *buf, unsigned char len) //ݶȡݽָbufȡ
             -ݳlenֵΪʵʶȡݳ
  40          {
  41   1          unsigned char i;
  42   1          if (len > cntRxd) //ȡȴڽյݳʱ
  43   1          {
  44   2              len = cntRxd; //ȡΪʵʽյݳ
  45   2          }
  46   1           for (i=0; i<len; i++) //յ
  47   1           {
  48   2              *buf = bufRxd[ i];
  49   2              buf++;
  50   2          }
  51   1          cntRxd = 0;  //ռ
  52   1          
  53   1          return len;  //ʵʶȡ
  54   1      }
C51 COMPILER V9.01   RS485                                                                 08/10/2016 16:12:08 PAGE 2   

  55          
  56          void DelayX10us(unsigned char t)  //ʱʱʱ(t*10)us
  57          {
  58   1          do {
  59   2              _nop_();
  60   2              _nop_();
  61   2              _nop_();
  62   2              _nop_();
  63   2              _nop_();
  64   2              _nop_();
  65   2              _nop_();
  66   2              _nop_();
  67   2              } while (--t);
  68   1       }
  69          
  70          void UartWrite(unsigned char *buf, unsigned char len) //д뺯ڷͺָbu
             -fݳlen
  71           {
  72   1          RS485_DIR = 1;  //RS485Ϊ
  73   1           while (len--)   //
  74   1           {
  75   2              flagOnceTxd = 0;
  76   2              SBUF = *buf;
  77   2              buf++;
  78   2              while (!flagOnceTxd);
  79   2          }
  80   1          DelayX10us(5);  //ȴֹͣλɣʱʱɲʾ
  81   1          RS485_DIR = 0;  //RS485Ϊ
  82   1      }
  83          
  84          
  85          
  86          void UartDriver() //յִӦ
  87          {
  88   1          unsigned char len;
  89   1          unsigned char buf[30];
  90   1          if (cmdArrived) //ʱȡ
  91   1          {
  92   2              cmdArrived = 0;
  93   2              len = UartRead(buf, sizeof(buf)-2); //յȡ
  94   2             // buf[len++] = '\r';   //ڽյ֡ӻз󷢻
  95   2              //buf[len++] = '\n';
  96   2              UartWrite(buf, len);
  97   2           }
  98   1      }
  99          
 100          
 101          
 102          void UartRxMonitor(unsigned char ms)  //ڽռغ
 103          {
 104   1          static unsigned char cntbkp = 0;
 105   1          static unsigned char idletmr = 0;
 106   1          if (cntRxd > 0)  //ռʱ߿ʱ
 107   1          {
 108   2              if (cntbkp != cntRxd)  //ռı䣬սյʱмʱ
 109   2              {
 110   3                  cntbkp = cntRxd;
 111   3                   idletmr = 0;
 112   3              }
 113   2              else
 114   2              {
 115   3                  if (idletmr < 30)  //ռδı䣬߿ʱۻʱ
C51 COMPILER V9.01   RS485                                                                 08/10/2016 16:12:08 PAGE 3   

 116   3                  {
 117   4                      idletmr += ms;
 118   4                      if (idletmr >= 30)  //ʱ䳬30msΪһ֡
 119   4                      {
 120   5                          cmdArrived = 1; //־
 121   5                       }
 122   4                  }
 123   3              }
 124   2          }
 125   1          else
 126   1          {
 127   2              cntbkp = 0;
 128   2          }
 129   1      }
 130          
 131          void InterruptUART() interrupt 4  //UARTжϷ
 132          {
 133   1          if (RI)  //յֽ
 134   1          {
 135   2              RI = 0;   //ֶжϱ־λ
 136   2              if (cntRxd < sizeof(bufRxd)) //ջδʱ
 137   2                {
 138   3                     bufRxd[cntRxd++] = SBUF; //ֽڣ
 139   3               }
 140   2          }
 141   1          if (TI)  //ֽڷ
 142   1          {
 143   2                      TI = 0;   //ֶ㷢жϱ־λ
 144   2              flagOnceTxd = 1;  //õηɱ־
 145   2          }
 146   1      
 147   1      }
 148          
 149          /***********************main.cļԴ*************************/
 150          
 151          #include <reg52.h>
 152          
 153          unsigned char T0RH = 0;  //T0ֵĸֽ
 154          unsigned char T0RL = 0;  //T0ֵĵֽ
 155          
 156          void ConfigTimer0(unsigned int ms);
 157          extern void ConfigUART(unsigned int baud);
 158          extern void UartRxMonitor(unsigned char ms);
 159          extern void UartDriver();
 160          
 161          void main ()
 162          {
 163   1          EA = 1;           //ж
 164   1          ConfigTimer0(1);  //T0ʱ1ms
 165   1          ConfigUART(9600); //òΪ9600
 166   1          while(1)
 167   1          {
 168   2              UartDriver();
 169   2          }
 170   1      }
 171          
 172          
 173          
 174          void ConfigTimer0(unsigned int ms)  //T0ú
 175          {
 176   1          unsigned long tmp;
 177   1      
C51 COMPILER V9.01   RS485                                                                 08/10/2016 16:12:08 PAGE 4   

 178   1          tmp = 11059200 / 12;      //ʱƵ
 179   1          tmp = (tmp * ms) / 1000;  //ļֵ
 180   1          tmp = 65536 - tmp;        //㶨ʱֵ
 181   1          tmp = tmp + 34;           //жӦʱɵ
 182   1      
 183   1          T0RH = (unsigned char)(tmp >> 8);  //ʱֵΪߵֽ
 184   1          T0RL = (unsigned char)tmp;
 185   1          TMOD &= 0xF0;   //T0Ŀλ
 186   1          TMOD |= 0x01;   //T0Ϊģʽ1
 187   1          TH0 = T0RH;     //T0ֵ
 188   1          TL0 = T0RL;
 189   1          ET0 = 1;        //ʹT0ж
 190   1          TR0 = 1;        //T0
 191   1      }
 192          
 193          void InterruptTimer0() interrupt 1  //T0жϷ
 194          {
 195   1          TH0 = T0RH;  //ʱ¼ֵ
 196   1          TL0 = T0RL;
 197   1          UartRxMonitor(1);  //ڽռ
 198   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    416    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     40    ----
   DATA SIZE        =      5      34
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
