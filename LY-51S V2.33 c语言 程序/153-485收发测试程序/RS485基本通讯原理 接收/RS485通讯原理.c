 
/*-----------------------------------------------
  名称：串口通信 rs485
  网站：www.doflye.net
  编写：shifang
  日期：2009.5
  修改：无
  内容：485 与 232 使用相同软件协议，是半双工，需要有2套开发板对发测试，或者使用
        另外一个485设备配套，这里提供测试程序
        接收端接线方式如下：
        P2.0----E(J40) 收发控制端
        TDX ----DI(J40)数据接收 针对485而言
        RXD ----RO(J40)数据发送 针对485而言

        A，B分别连接另一块开发板的 A，B

        接收端使用独立数码管显示1-8数字：
        P1 ----- J6 独立数码管
		或者使用
		P0 ----- J9 LED显示二进制数值
------------------------------------------------*/

#include<reg52.h> //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义                        
#include"delay.h"
#include "1602.h"

unsigned char code dofly_table[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,};
 // 显示数值表0-9

void SendByte(unsigned char dat);
/*------------------------------------------------
                硬件端口定义
------------------------------------------------*/

sbit Ctrl_EN = P2^0;  //发送接收控制端
/*------------------------------------------------
                 函数声明
------------------------------------------------*/
void SendStr(unsigned char *s);
/*------------------------------------------------
                串口初始化
------------------------------------------------*/
void InitUART  (void)
{

    SCON  = 0x50;		        // SCON: 模式 1, 8-bit UART, 使能接收  
    TMOD |= 0x20;               // TMOD: timer 1, mode 2, 8-bit 重装
    TH1   = 0xFD;               // TH1:  重装值 9600 波特率 晶振 11.0592MHz  
    TR1   = 1;                  // TR1:  timer 1 打开                         
    EA    = 1;                  //打开总中断
    ES    = 1;                  //打开串口中断
}                            
/*------------------------------------------------
                    主函数
------------------------------------------------*/
void main (void)
{
InitUART();

Ctrl_EN=0;  //接收模式

while (1)                       
    {

    }
}


/*------------------------------------------------
                     串口中断程序
------------------------------------------------*/
void UART_SER (void) interrupt 4 //串行中断服务程序
{
    unsigned char Temp;          //定义临时变量 
   
   if(RI)                        //判断是接收中断产生
     {
	  RI=0;                      //标志位清零
	  Temp=SBUF;                 //读入缓冲区的值
	  P1=dofly_table[Temp];
      P0=Temp;
	 }
   if(TI)                        //如果是发送标志位，清零
     TI=0;
} 

